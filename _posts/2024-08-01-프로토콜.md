---
title: [1주차 TIL] KnockOn Bootcamp - 프로토콜
published: true
---

|

# OSI 7계층, 프로토콜

각 계층은 특정한 기능을 담당하며, 계층 간의 상호작용을 통해 데이터를 전달

서로 다른 시스템 간의 통신을 가능하게 하여 표준화된 네트워크 통신 보장

특정 계층의 변경이 다른 계층에 영향을 미치지 않도록 설계됨

|

### 1. **`물리 계층 (Physical Layer)`**: 물리적 연결 및 전송
데이터를 전기 신호로 변환하여 물리적인 매체(케이블, 무선 등)를 통해 전송
- 예: 케이블, 허브, 리피터, 전압 수준, 전선 핀 배열

**`프로토콜/기술`**:  
이더넷 (Ethernet) 물리적 표준 (예: 10Base-T, 100Base-TX)  
광섬유 표준 (예: SONET, SDH)  
  
|
  
### 2. **`데이터 링크 계층 (Data Link Layer)`**: **MAC 주소**를 이용한 **데이터 프레임** 전송
물리 계층을 통해 전송된 데이터의 오류를 검출하고, 필요한 경우 재전송하며, 네트워크 간 노드 간의 직접 연결을 제공
- 예: 스위치(switch), 브릿지(bridge)

**`프로토콜`**:  
이더넷 (Ethernet)  
PPP (Point-to-Point Protocol)  
HDLC (High-Level Data Link Control)  
프레임 릴레이 (Frame Relay)  
ATM (Asynchronous Transfer Mode)  

|

### 3. **`네트워크 계층 (Network Layer)`**: **IP 주소**를 이용한 **패킷** 전송
패킷의 경로를 설정하고 데이터를 목적지로 전송하기 위해 최적의 경로를 찾음

- 예: 라우터

**`프로토콜`**:  
IP (Internet Protocol): IPv4, IPv6  
ICMP (Internet Control Message Protocol)  
IGMP (Internet Group Management Protocol)  
RIP (Routing Information Protocol)  
OSPF (Open Shortest Path First)  
BGP (Border Gateway Protocol)  
  
|

### 4. **`전송 계층 (Transport Layer)`**: **TCP/UDP 프로토콜**을 이용한 **데이터** 전송
데이터의 전송을 관리하고, 흐름 제어, 오류 제어 및 재전송을 수행

**`프로토콜`**:  
TCP (Transmission Control Protocol)  
UDP (User Datagram Protocol)  
SCTP (Stream Control Transmission Protocol)  

|

### 5. **`세션 계층 (Session Layer)`**: 연결 및 통신 세션 관리
데이터 교환을 관리하고 동기화를 제공하여 통신 세션을 설정, 유지 및 해제

**`프로토콜`**:  
NetBIOS  
PPTP (Point-to-Point Tunneling Protocol)  
RPC (Remote Procedure Call)  

|

### 6. **`표현 계층 (Presentation Layer)`**: 데이터의 인코딩/디코딩, 암호화/복호화, 압축/해제
데이터의 표현 방법을 정의하고 암호화, 복호화, 압축 등의 데이터 변환을 수행

**`프로토콜`**:  
SSL/TLS (Secure Sockets Layer / Transport Layer Security)  
JPEG (이미지 포맷)  
MPEG (비디오 포맷)  
ASCII (문자 인코딩)  

|

### 7. **`응용 계층 (Application Layer)`**: 사용자에게 직접 서비스 제공(예: HTTP, FTP..)
사용자와 네트워크 간의 상호 작용을 지원하는 계층으로, 이메일, 파일 전송, 웹 브라우징 등과 같은 응용 프로그램에 직접적으로 연결됨

**`프로토콜`**:  
 HTTP (Hypertext Transfer Protocol)  
 HTTPS (HTTP Secure)  
 FTP (File Transfer Protocol)  
 SMTP (Simple Mail Transfer Protocol)  
 POP3 (Post Office Protocol 3)
 IMAP (Internet Message Access Protocol)  
 DNS (Domain Name System)  
 Telnet  
 SSH (Secure Shell)  

|

---

|

# TCP와 UDP

## **`TCP(Transmission Control Protocol)`**: 데이터를 잘 보냄

**`연결 지향적 (Connection-Oriented)`**

데이터 전송 전에 연결을 설정하여 전송의 신뢰성 보장

*`3 Way-Handshake`*(요청, 응답, 확인)을 통해 연결 설정

|

**`신뢰성 (Reliability)`**

데이터의 전송이 완료되었는지 확인 -> 데이터 손실이나 오류 발생 시 재전송

데이터가 **송신 순서대로** 수신되도록 보장

|

**`흐름 제어 (Flow Control)`**: 1:1 상황에서 빠름

송신자가 수신자의 처리 능력을 초과하지 않도록 설정하여 **과부하 방지**

|

**`혼잡 제어 (Congestion Control)`**: 1:1보다는 전체적인 성능 향상

네트워크 혼잡 상황을 감지, 데이터 전송 속도를 조절하여 네트워크 성능 유지

|

**`데이터 전송 단위`**

TCP는 데이터를 *`세그먼트 (Segment)`* 단위로 나누어 전송

|

### 장점
신뢰성 있는 데이터 전송  
순서 보장  
데이터의 정확성 보장  

|

### 단점
지연 발생 가능(연결 설정, 흐름 제어, 혼잡 제어로 인한 지연)  
오버헤드가 큼 (추가적인 제어 정보 및 처리 필요)  

|

### 사용 예
웹 브라우징 (HTTP/HTTPS)  
파일 전송 (FTP)  
이메일 전송 (SMTP)  

|

## **`UDP(User Datagram Protocol)`**: 데이터를 막 보냄

**`비연결 지향적 (Connectionless)`**

데이터 전송 전에 연결 설정 없음

데이터가 수신자에게 전달되는지 여부를 확인하지 않음

|

**`신뢰성 없음 (Unreliable)`**

데이터의 손실, 중복, 순서 변경 등의 오류 처리를 하지 않음

데이터가 손실되거나 잘못된 순서로 도착할 수 있음

|

**`속도`**

연결 설정과 오류 검출이 없어 빠른 데이터 전송 가능

|

**`데이터 전송 단위`**

UDP는 데이터를 *`데이터그램`* 단위로 전송

|

### 장점
빠른 전송 속도  
낮은 오버헤드  
간단한 구현

|

### 단점
신뢰성 없음(데이터 손실, 중복 가능)  
순서 보장 없음  

|

### 사용 예
실시간 서비스(온라인 게임, 스트리밍..)  
DNS 요청  
DHCP ( Dynamic Host Configuration Protocol)  

|

| 특성             | TCP                           |  UDP          |
|:-----------------|:------------------------------|:--------------|
| 연결             | 연결 지향적 (3 Way-Handshake) | 비연결 지향적 |
| 신뢰성           | 신뢰성 있음                   | X             |
| 순서 보장        | 순서 보장                     | X             |
| 흐름 제어        | O                             | X             |
| 혼잡 제어        | O                             | X             |
| 속도             | 상대적으로 느림               | 빠름          |
| 데이터 전송 단위 | 세그먼트                      | 데이터그램    |

|

---

|

# TCP와 IP의 연계

TCP와 IP는 서로 다른 계층에서 동작하지만, 서로 협력하여 데이터를 효율적으로 전송함

|

## **데이터 전송 과정**

### 1. **`응용 계층`**: *`메시지`* 생성(예: 웹 브라우저에서 요청하는 HTTP 데이터, 이메일 등)  

|

### 2. **`전송 계층 (TCP)`**: *`세그먼트`* 또는 *`데이터그램`* 생성  

TCP: *`메시지`*를 *`세그먼트`*로 나눔. *`세그먼트`*에는 **출발지/목적지 포트 번호**, **TCP 헤더**가 포함되어 전송의 신뢰성과 순서를 보장  

UDP: *`메시지`*를 *`데이터그램`*으로 나눔. 데이터그램도 포트 번호를 포함하지만, 신뢰성과 순서 보장은 하지 않음  

|

### 3. **`네트워크 계층 (IP)`**: *`패킷`* 생성  

*`TCP 세그먼트`* 또는 *`UDP 데이터그램`*은 *`IP 패킷`*으로 *캡슐화*되어 네트워크 계층으로 전달  

*IP*는 *패킷*에 목적지 IP 주소를 추가하여 적절한 경로를 통해 목적지까지 전달  

|

### 4. **`데이터 링크 계층`**: *`프레임`* 생성  

*`IP 패킷`*을 *`프레임`*으로 *캡슐화*  

*`프레임`*에는 *물리 주소(MAC 주소)*와 같은 데이터 링크 계층 정보를 포함하여 동일 네트워크 내에서의 전송을 지원  

|

### 5. **`물리 계층`**: *`비트 스트림`* 생성

*`프레임`*은 물리 계층에서 실제 전송 매체(케이블, 무선..)를 통해 전송  

|

## **패킷 전송 및 수신**  

송신자: TCP 세그먼트를 IP 패킷으로 캡슐화하여 네트워크를 통해 전송  

수신자: IP 패킷을 수신, IP 패킷에서 TCP 세그먼트 추출  
--> TCP는 세그먼트의 순서와 무결성을 검사하고, 필요한 경우 재전송을 요청  

|

## **상위 계층과의 연계**  

TCP는 전송 계층에서 데이터의 신뢰성을 보장 후, 응용 계층의 애플리케이션에게 데이터를 전달  

IP는 네트워크 계층에서 패킷의 라우팅을 담당, 패킷이 최종 목적지까지 도달하도록 함  

|
  
## 정리

**`IP (Internet Protocol)`**: 데이터의 라우팅과 주소 지정을 담당하며, 패킷을 목적지까지 전달  

**`TCP (Transmission Control Protocol)`**: 데이터의 신뢰성, 순서 보장, 흐름 제어, 혼잡 제어를 담당하며, 신뢰성 있는 데이터 전송을 보장  

|

TCP는 IP 위에서 동작하며, 데이터 전송의 신뢰성을 보장하기 위해 IP의 패킷 전송 기능을 사용함  

IP는 데이터를 목적지까지 전달하고, TCP는 데이터의 정확한 전송과 순서를 관리함  

|


|         |              | PDU, Protocol Data Unit |
|:--------|:-------------|:------------------------|
| Layer 7 | Application  | Data                    |
| Layer 6 | Presentation | Data                    |
| Layer 5 | Session      | Data                    |
| Layer 4 | Transport    | Segment                 |
| Layer 3 | Network      | Packet                  |
| Layer 2 | Data Link    | Frame                   |
| Layer 1 | Physical     | Bit/Signal              |

|

---

|

# 3 Way-Handshake (TCP 연결 설정)

*3-Way Handshake*는 *TCP (Transmission Control Protocol)*에서 신뢰성 있는 연결을 설정하기 위해 사용하는 과정  

세 단계로 구성되며, 클라이언트와 서버 간의 통신이 시작될 때 실행됨

|

## 1. **`SYN (Synchronize)`**: 클라이언트 -> 서버

클라이언트는 서버에 연결 요청을 보내기 위해 ***SYN 패킷*** 전송  

패킷에는 초기 순서 번호(ISN, Initial Sequence Number)가 포함되어 있음 

- 예: 클라이언트가 서버에 SYN 패킷(Sequence Number: **`x`**)을 보냄

|

## 2. **`SYN-ACK (Synchronize-Acknowledge)`**: 서버 -> 클라이언트

서버는 클라이언트의 ***SYN 패킷***을 받고, 확인을 위해 ***ACK 패킷***을 전송  

***ACK 패킷***을 전송함과 동시에 자신도 클라이언트에게 연결 요청을 보내기 위해 ***SYN 패킷*** 전송

두 패킷이 하나의 ***SYN-ACK 패킷***으로 결합됨  

- 예: 서버가 클라이언트에 SYN-ACK 패킷(Sequence Number: **`y`**, Acknowledgement Number: **`x+1`**)을 보냄

|

## 3. **`ACK (Acknowledge)`**: 클라이언트 -> 서버

클라이언트는 서버의 ***SYN-ACK 패킷***을 받고, 확인을 위해 ***ACK 패킷*** 전송  

패킷에는 서버의 ISN에 대한 응답으로 ACK 번호가 포함되어 있음  

- 예: 클라이언트가 서버에 ACK 패킷(Acknowledgement Number: **`y+1`**)을 보냄

|

---

|

# 4 Way-Handshake (TCP 연결 해제)

*4-Way Handshake*는 TCP에서 연결을 안전하게 종료하기 위해 사용하는 과정  

네 단계로 구성되며, 연결 종료를 위해 양측에서 각각 연결 해제 요청을 해야함  

> 클라이언트가 서버에 종료 요청을 한다고 가정.  

|

## 1. **`FIN (Finish)`**: 종료하는 측(클라이언트) -> 서버  

연결을 종료하려는 측이 ***FIN 패킷***을 전송하여 연결 종료 의사를 밝힘  

- 예: 클라이언트가 서버에 FIN 패킷(Sequence Number: **`x`**)을 보냄

|

## 2. **`ACK (Acknowledge)`**: 서버 -> 클라이언트

반대 측은 ***FIN 패킷***을 받고, 확인을 위해 ***ACK 패킷***을 전송  

- 예: 서버가 클라이언트에 ACK 패킷(Acknowledgement Number: **`x+1`**)을 보냄

|

## 3. **`FIN`**: 서버 -> 클라이언트

반대 측도 연결을 종료하기 위해 FIN 패킷을 전송  

- 예: 서버가 클라이언트에 FIN 패킷(Sequence Number: **`y`**)을 보냄

|

## 4. **`ACK`**: 클라이언트 -> 서버

처음 FIN 패킷을 보낸 측은 서버의 FIN 패킷을 받고, 확인을 위해 ACK 패킷을 전송  

- 예: 클라이언트가 서버에 ACK 패킷(Acknowledgement Number: **`y+1`**)을 보냄

마지막 ACK 패킷을 보낸 측은 일정 시간 동안 대기(**`TIME_WAIT 상태`**)하여 중간에 손실된 패킷이 다시 전달되는 것을 방지함

|

---

|

# IPv4, IPv6

## IPv4 (Internet Protocol version 4)

### 구조

주소 형식: 32비트 주소 체계 사용  

주소 표현: 4개의 10진수로 표현  
각 10진수는 8비트(0-255)로 구분  
- 예: '192.168.0.1'  

주소 수: *2^32*(약 43억) 개 의 주소 제공  

| 

### 특징  

주소 부족: 전 세계적으로 인터넷 사용자 증가로 인해 IPv4 주소 부족 문제 발생  

네트워크 분할: *서브넷 마스크*를 사용해 네트워크 분할 가능  

주소 할당: 주로 *DHCP(Dynamic Host Configuration Protocol)*를 통해 동적 할당됨  

NAT 사용: 주소 부족 문제 해결을 위해 NAT(Network Address Translation)가 사용됨  

|

### IPv4 데이터그램 포맷

![IPv4 데이터그램 포맷](./assets/images/ipv4_데이터그램포맷.png)  

**`버전(ver)`**: 4비트, IPv4임을 나타냄  

**`헤더 길이(head len)`**: 4비트, 헤더의 길이

**`서비스 유형 TOS(type of service)`**:  8비트, 패킷의 우선순위를 지정  

**`총 길이(length)`**: 16비트, 패킷 전체의 길이

|

**`식별자(16-bit-identifier)`**: 16비트, 패킷 고유 식별자  

**`플래그(flgs)`**: 3비트, 패킷 분할 시 사용  

**`오프셋(fragment offset)`**: 13비트, 패킷 분할 시 사용

|

**`TTL(Time to Live)`**: 8비트, 패킷의 수명 

**`프로토콜(upper layer)`**: 8비트, 상위 계층 프로토콜을 나타냄  

**`헤더 체크섬(header checksum)`**: 16비트, 헤더의 오류 검출을 위해 사용됨  

|

**`출발지 주소(source IP address)`**: 32비트, 발신자(출발지)의 IP 주소

|

**`목적지 주소(destination IP address)`**: 32비트, 수신자(목적지)의 IP 주소

|

## IPv6 (Internet Protocol version 6)

### 구조 

주소 형식: 128비트 주소 체계 사용

주소 표현: 16진수로 표현  
콜론(:)으로 구분된 8개의 그룹으로 나타냄  
- 예: '2001:0db8:85a3:0000:0000:8a2e:0370:7334'  

주소 수: *2^128* 개로 사실상 무제한에 가까운 주소 제공  

|

### 특징  

확장성: IPv4에 비해 훨씬 많은 주소 제공  

자동 구성: *SLAAC(Stateless Address Autoconfiguration)*를 통해 자동으로 주소 구성 가능  

향상된 라우팅: 간소화된 헤더 구조로 라우팅 성능 향상  

보안 기능 내장: *IPsec*을 기본적으로 지원하여 보안 강화  

|

### IPv6 데이터그램 포맷

![IPv6 데이터그램 포맷](./assets/images/ipv6_데이터그램포맷.png) 

**`버전(ver)`**: 4비트, IPv6임을 나타냄  

**`트래픽 클래스(pri)`**: 8비트, 패킷의 우선순위를 지정  

**`플로우 라벨(flow label)`**: 20비트, 특정 플로우에 대한 식별자  

|

**`페이로드 길이`**: 16비트, 페이로드(데이터)의 길이  

**`넥스트 헤더`**: 8비트, 다음에 오는 헤더의 타입  

**`홉 제한`**: 8비트, 패킷의 수명  

|

**`출발지 주소`**: 128비트, 발신자(출발지)의 IP 주소

|

**`목적지 주소`**: 128비트, 수신자(목적지)의 IP 주소

|

### 전환 매커니즘

**듀얼 스택**: 장치가 IPv4와 IPv6를 모두 지원하여 두 프로토콜을 동시에 사용

- 점진적인 IPv6 도입을 위해 IPv4와 IPv6가 동시에 작동하도록 하여 두 프로토콜 간의 원활한 전환을 지원

|

**터널링**: IPv6 패킷을 IPv4 네트워크를 통해 전달하기 위해 터널링 사용

- IPv4 인프라를 활용하여 IPv6 패킷을 전송하고, 점진적으로 IPv6 네트워크로 전환할 수 있도록 지원

- 예: 6to4 Teredo, ISATAP

|

**주소 변환**: IPv4와 IPv6 사이의 호환성을 위해 IP 주소 변환 기술 사용

- IPv4와 IPv6 간의 직접 통신을 지원하여 네트워크 전환을 원활하게 만들어줌

- 예: NAT64, DNS64

|

---

|

# DNS (Domain Name System)

인터넷에서 도메인 이름을 IP 주소로 변환하는 시스템(인터넷의 전화번호부)  

사람이 이해하기 쉬운 도메인 이름을 컴퓨터가 이해할 수 있는 숫자 IP 주소로 변환  

- 예: www.naver.com -> 223.130.200.236

|

## DNS 서버

**`루트 DNS 서버`**: 최상위 수준의 DNS 서버로, 모든 도메인 이름의 최상위 도메인(TLD)에 대한 정보를 갖고 있음

**`TLD DNS 서버`**: 특정 최상위 도메인에 대한 정보 제공 (*.com* 또는 *.org*)

**`권한 있는 DNS 서버`**: 특정 도메인에 대한 권한을 갖고 있으며, 해당 도메인 이름의 IP 주소를 제공

**`재귀적 DNS 서버`**: 사용자의 DNS 쿼리를 받아 필요한 정보를 찾기 위해 여러 DNS 서버에 쿼리를 보내는 서버

|

## DNS 동작 방식

### 1. **`DNS 쿼리`**

사용자가 웹 브라우저에 *www.도메인이름.com*을 입력하면, 컴퓨터는 *재귀적 DNS 서버*에 도메인 이름의 *IP 주소*를 요청

|

### 2. **`루트 DNS 서버`**

*재귀적 DNS 서버*는 *루트 DNS 서버*에 쿼리를 보내고, 루트 서버는 *.com TLD 서버*의 주소를 반환

|

### 3. **`TLD DNS 서버`**

*재귀적 DNS 서버*는 받은 주소로 *.com TLD 서버*에 쿼리를 보내고, *TLD 서버*는 *도메인이름.com*에 대한 *권한 있는 DNS 서버*의 주소를 반환

|

### 4. **`권한 있는 DNS 서버`**

*재귀적 DNS 서버*는 최종적으로 *권한 있는 DNS 서버*에 쿼리를 보내고, 이 서버는 *www.도메인이름.com*의 *IP 주소*를 반환

|

### 5. **`IP 주소 반환`**

*재귀적 DNS 서버*는 *IP 주소*를 사용자에게 반환하고, 사용자의 컴퓨터는 이 *IP 주소*를 사용하여 웹사이트에 접속

|

---

|

# 포트

컴퓨터 네트워크에서 특정 프로세스나 서비스와의 통신을 식별하기 위해 사용하는 논리적 단위

네트워크에서 데이터를 주고받을 때, IP 주소는 목적지를 식별, 포트 번호는 목적지 내의 특정 서비스를 식별함

포트 번호는 0부터 65535까지의 숫자로 이루어짐

|

**`잘 알려진 포트 (Well-Known Ports)`**: 0 ~ 1023  

주로 표준화된 서비스에 할당됨

HTTP: 포트 80  

HTTPS: 포트 443  

FTP: 포트 21  

|

**`등록된 포트 (Registered Ports)`**: 1024 ~ 49151  

특정 애플리케이션이나 서비스가 사용하도록 등록됨

|

**`동적 및 사설 포트 (Dynamic and Private Ports)`**: 49152 ~ 65535

임시 목적으로 클라이언트 측에서 사용됨

|

---

|

# 포트포워딩

라우터나 방화벽이 특정 포트로 들어오는 *네트워크 트래픽*을 내부 네트워크의 *특정 IP 주소와 포트로 전달*하는 기술

포트 포워딩을 통해 외부에서 내부 네트워크의 특정 서비스에 접근할 수 있음

|

## 필요성

|

**`원격 접속`**: 원격지에서 내부 네트워크의 특정 서비스에 접근하기 위해 필요(웹 서버, 게임 서버 등)

|

**`보안`**: 내부 네트워크의 IP 주소를 숨기고, 특정 포트만 개방하여 보안 강화

|

**`네트워크 관리`**: 네트워크 트래픽을 효율적으로 관리, 특정 서비스에 대한 접근 제어

|

## 설정 방법

### 1. **`라우터 접속`**: 웹 브라우저를 통해 라우터의 관리 페이지에 접속

|

### 2. **`포트 포워딩 설정`**: 라우터 설정 메뉴에서 '포트 포워딩' 섹션을 찾음

|

### 3. **`포트 포워딩 규칙 추가`**:

**서비스 이름**: 규칙의 이름 지정

**포트 범위**: 포워딩할 포트 번호 입력

**프로토콜**: TCP/UDP 중 하나 혹은 둘 다 선택

**내부 IP 주소**: 트래픽을 전달할 내부 네트워크의 IP 주소 입력

**내부 포트**: 내부 네트워크의 특정 서비스가 사용하는 포트 번호를 입력

|

### 4. **`설정 저장`**: 설정 적용을 위해 규칙 저장 및 라우터 재시작

|

## 예

**내부 네트워크 컴퓨터에서 웹 서버를 운영중일 때, 외부에서 해당 웹 서버에 접근하기 위해서는 포트 포워딩을 설정해야함**

|

**외부 포트**: 80 (HTTP)

**내부 IP 주소**: 192.168.1.100

**내부 포트**: 80

|

> 위와 같이 설정 시, 외부에서 라우터의 공인 IP 주소로 포트 80에 접근할 때, 해당 트래픽이 내부 IP 주소 192.168.1.100의 포트 80으로 전달됨

|

---

|